From e54cdc33da095bebd6c6bf0d2cc502bb7549b072 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?David=20H=C3=A9rault?= <dherault@gmail.com>
Date: Sat, 22 Jun 2019 18:41:22 +0200
Subject: [PATCH] Lint and rename folders

---
 .eslintignore                                 |   5 +-
 .eslintrc.js                                  |   4 +
 manual_test_nodejs/handler.js                 |   3 +-
 manual_test_nodejs/subprocess.js              |   1 -
 .../RouteSelection/handler.js                 |  31 ++
 .../package-lock.json                         |   0
 .../package.json                              |   0
 .../scripts/deploy_to_aws.sh                  |   0
 .../scripts/deploy_to_offline.sh              |   0
 .../scripts/serverless..yml                   |   0
 .../scripts/serverless.aws.yml                |   0
 .../scripts/serverless.offline.yml            |   0
 .../serverless.yml                            |   0
 .../RouteSelection/test/e2e/ws.e2e.js         |  59 +++
 .../test/support/WebSocketTester.js           |  62 +++
 manual_test_websocket/main/handler.js         | 131 +++++++
 .../package-lock.json                         |   0
 .../package.json                              |   0
 .../scripts/deploy_to_aws.sh                  |   0
 .../scripts/deploy_to_offline.sh              |   0
 .../scripts/serverless..yml                   |   0
 .../scripts/serverless.aws.yml                |   0
 .../scripts/serverless.offline.yml            |   0
 .../serverless.yml                            |   0
 manual_test_websocket/main/test/e2e/ws.e2e.js | 360 ++++++++++++++++++
 .../main/test/support/WebSocketTester.js      |  62 +++
 .../handler.js                                |  37 --
 .../test/e2e/ws.e2e.js                        |  53 ---
 .../test/support/WebSocketTester.js           |  62 ---
 .../manual_test_websocket_main/handler.js     | 150 --------
 .../test/e2e/ws.e2e.js                        | 342 -----------------
 .../test/support/WebSocketTester.js           |  60 ---
 32 files changed, 711 insertions(+), 711 deletions(-)
 create mode 100644 manual_test_websocket/RouteSelection/handler.js
 rename manual_test_websocket/{manual_test_websocket_RouteSelection => RouteSelection}/package-lock.json (100%)
 rename manual_test_websocket/{manual_test_websocket_RouteSelection => RouteSelection}/package.json (100%)
 rename manual_test_websocket/{manual_test_websocket_RouteSelection => RouteSelection}/scripts/deploy_to_aws.sh (100%)
 rename manual_test_websocket/{manual_test_websocket_RouteSelection => RouteSelection}/scripts/deploy_to_offline.sh (100%)
 rename manual_test_websocket/{manual_test_websocket_RouteSelection => RouteSelection}/scripts/serverless..yml (100%)
 rename manual_test_websocket/{manual_test_websocket_RouteSelection => RouteSelection}/scripts/serverless.aws.yml (100%)
 rename manual_test_websocket/{manual_test_websocket_RouteSelection => RouteSelection}/scripts/serverless.offline.yml (100%)
 rename manual_test_websocket/{manual_test_websocket_RouteSelection => RouteSelection}/serverless.yml (100%)
 create mode 100644 manual_test_websocket/RouteSelection/test/e2e/ws.e2e.js
 create mode 100644 manual_test_websocket/RouteSelection/test/support/WebSocketTester.js
 create mode 100644 manual_test_websocket/main/handler.js
 rename manual_test_websocket/{manual_test_websocket_main => main}/package-lock.json (100%)
 rename manual_test_websocket/{manual_test_websocket_main => main}/package.json (100%)
 rename manual_test_websocket/{manual_test_websocket_main => main}/scripts/deploy_to_aws.sh (100%)
 rename manual_test_websocket/{manual_test_websocket_main => main}/scripts/deploy_to_offline.sh (100%)
 rename manual_test_websocket/{manual_test_websocket_main => main}/scripts/serverless..yml (100%)
 rename manual_test_websocket/{manual_test_websocket_main => main}/scripts/serverless.aws.yml (100%)
 rename manual_test_websocket/{manual_test_websocket_main => main}/scripts/serverless.offline.yml (100%)
 rename manual_test_websocket/{manual_test_websocket_main => main}/serverless.yml (100%)
 create mode 100644 manual_test_websocket/main/test/e2e/ws.e2e.js
 create mode 100644 manual_test_websocket/main/test/support/WebSocketTester.js
 delete mode 100644 manual_test_websocket/manual_test_websocket_RouteSelection/handler.js
 delete mode 100644 manual_test_websocket/manual_test_websocket_RouteSelection/test/e2e/ws.e2e.js
 delete mode 100644 manual_test_websocket/manual_test_websocket_RouteSelection/test/support/WebSocketTester.js
 delete mode 100644 manual_test_websocket/manual_test_websocket_main/handler.js
 delete mode 100644 manual_test_websocket/manual_test_websocket_main/test/e2e/ws.e2e.js
 delete mode 100644 manual_test_websocket/manual_test_websocket_main/test/support/WebSocketTester.js

diff --git a/.eslintignore b/.eslintignore
index 211df65..cf70988 100644
--- a/.eslintignore
+++ b/.eslintignore
@@ -1,4 +1 @@
-manual_test_nodejs
-manual_test_python
-manual_test_ruby
-manual_test_websocket
+**/node_modules
diff --git a/.eslintrc.js b/.eslintrc.js
index 5c7d6c5..cf14cb5 100644
--- a/.eslintrc.js
+++ b/.eslintrc.js
@@ -21,4 +21,8 @@ if (env.TRAVIS && platform === 'win32') {
 module.exports = {
   extends: 'dherault',
   rules,
+  env: {
+    node: true,
+    mocha: true,
+  },
 };
diff --git a/manual_test_nodejs/handler.js b/manual_test_nodejs/handler.js
index 568b4dc..12b454a 100644
--- a/manual_test_nodejs/handler.js
+++ b/manual_test_nodejs/handler.js
@@ -1,4 +1,3 @@
-'use strict';
 
 module.exports.hello = (event, context, callback) => {
   const response = {
@@ -28,7 +27,7 @@ module.exports.rejectedPromise = (event, context, callback) => {
   callback(null, response);
 };
 
-module.exports.authFunction = (event, context, callback) => {
+module.exports.authFunction = (event, context) => {
   context.succeed({
     principalId: 'xxxxxxx', // the principal user identification associated with the token send by the client
     policyDocument: {
diff --git a/manual_test_nodejs/subprocess.js b/manual_test_nodejs/subprocess.js
index 9132207..7794c64 100644
--- a/manual_test_nodejs/subprocess.js
+++ b/manual_test_nodejs/subprocess.js
@@ -1,4 +1,3 @@
-'use strict';
 
 const { exec } = require('child_process');
 
diff --git a/manual_test_websocket/RouteSelection/handler.js b/manual_test_websocket/RouteSelection/handler.js
new file mode 100644
index 0000000..d43ffeb
--- /dev/null
+++ b/manual_test_websocket/RouteSelection/handler.js
@@ -0,0 +1,31 @@
+const AWS = require('aws-sdk');
+
+const successfullResponse = {
+  statusCode: 200,
+  body: 'Request is OK.',
+};
+
+module.exports.echo = async (event, context) => {
+  const action = JSON.parse(event.body);
+
+  await sendToClient(action.message, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context));
+
+  return successfullResponse;
+};
+
+const newAWSApiGatewayManagementApi = event => {
+  let endpoint = event.apiGatewayUrl;
+
+  if (!endpoint) endpoint = `${event.requestContext.domainName}/${event.requestContext.stage}`;
+  const apiVersion = '2018-11-29';
+
+  return new AWS.ApiGatewayManagementApi({ apiVersion, endpoint });
+};
+
+const sendToClient = (data, connectionId, apigwManagementApi) => {
+  // console.log(`sendToClient:${connectionId}`);
+  let sendee = data;
+  if (typeof data === 'object') sendee = JSON.stringify(data);
+
+  return apigwManagementApi.postToConnection({ ConnectionId: connectionId, Data: sendee }).promise();
+};
diff --git a/manual_test_websocket/manual_test_websocket_RouteSelection/package-lock.json b/manual_test_websocket/RouteSelection/package-lock.json
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_RouteSelection/package-lock.json
rename to manual_test_websocket/RouteSelection/package-lock.json
diff --git a/manual_test_websocket/manual_test_websocket_RouteSelection/package.json b/manual_test_websocket/RouteSelection/package.json
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_RouteSelection/package.json
rename to manual_test_websocket/RouteSelection/package.json
diff --git a/manual_test_websocket/manual_test_websocket_RouteSelection/scripts/deploy_to_aws.sh b/manual_test_websocket/RouteSelection/scripts/deploy_to_aws.sh
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_RouteSelection/scripts/deploy_to_aws.sh
rename to manual_test_websocket/RouteSelection/scripts/deploy_to_aws.sh
diff --git a/manual_test_websocket/manual_test_websocket_RouteSelection/scripts/deploy_to_offline.sh b/manual_test_websocket/RouteSelection/scripts/deploy_to_offline.sh
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_RouteSelection/scripts/deploy_to_offline.sh
rename to manual_test_websocket/RouteSelection/scripts/deploy_to_offline.sh
diff --git a/manual_test_websocket/manual_test_websocket_RouteSelection/scripts/serverless..yml b/manual_test_websocket/RouteSelection/scripts/serverless..yml
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_RouteSelection/scripts/serverless..yml
rename to manual_test_websocket/RouteSelection/scripts/serverless..yml
diff --git a/manual_test_websocket/manual_test_websocket_RouteSelection/scripts/serverless.aws.yml b/manual_test_websocket/RouteSelection/scripts/serverless.aws.yml
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_RouteSelection/scripts/serverless.aws.yml
rename to manual_test_websocket/RouteSelection/scripts/serverless.aws.yml
diff --git a/manual_test_websocket/manual_test_websocket_RouteSelection/scripts/serverless.offline.yml b/manual_test_websocket/RouteSelection/scripts/serverless.offline.yml
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_RouteSelection/scripts/serverless.offline.yml
rename to manual_test_websocket/RouteSelection/scripts/serverless.offline.yml
diff --git a/manual_test_websocket/manual_test_websocket_RouteSelection/serverless.yml b/manual_test_websocket/RouteSelection/serverless.yml
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_RouteSelection/serverless.yml
rename to manual_test_websocket/RouteSelection/serverless.yml
diff --git a/manual_test_websocket/RouteSelection/test/e2e/ws.e2e.js b/manual_test_websocket/RouteSelection/test/e2e/ws.e2e.js
new file mode 100644
index 0000000..fcd11c0
--- /dev/null
+++ b/manual_test_websocket/RouteSelection/test/e2e/ws.e2e.js
@@ -0,0 +1,59 @@
+/* eslint-disable import/no-extraneous-dependencies */
+
+const chai = require('chai');
+
+const WebSocketTester = require('../support/WebSocketTester');
+
+const expect = chai.expect;
+const endpoint = process.env.npm_config_endpoint || 'ws://localhost:3005';
+const timeout = process.env.npm_config_timeout ? parseInt(process.env.npm_config_timeout) : 1000;
+
+describe('serverless', () => {
+  describe('with WebSocket support', () => {
+    let clients = [];
+
+    const createWebSocket = async qs => {
+      const ws = new WebSocketTester();
+      let url = endpoint;
+
+      if (qs) url = `${endpoint}?${qs}`;
+
+      await ws.open(url);
+
+      clients.push(ws);
+
+      return ws;
+    };
+
+    beforeEach(() => {
+      clients = [];
+    });
+
+    afterEach(async () => {
+      await Promise.all(clients.map(async (ws, i) => {
+        const n = ws.countUnrecived();
+
+        if (n > 0) {
+          console.log(`unreceived:[i=${i}]`);
+          (await ws.receive(n)).forEach(m => console.log(m));
+        }
+
+        expect(n).to.equal(0);
+        ws.close();
+      }));
+
+      clients = [];
+    });
+
+    it('should call action \'echo\' handler located at service.do', async () => {
+      const ws = await createWebSocket();
+      const now = `${Date.now()}`;
+      const payload = JSON.stringify({ service:{ do:'echo' }, message:now });
+
+      ws.send(payload);
+
+      expect(await ws.receive1()).to.equal(`${now}`);
+    }).timeout(timeout);
+
+  });
+});
diff --git a/manual_test_websocket/RouteSelection/test/support/WebSocketTester.js b/manual_test_websocket/RouteSelection/test/support/WebSocketTester.js
new file mode 100644
index 0000000..aaeff5a
--- /dev/null
+++ b/manual_test_websocket/RouteSelection/test/support/WebSocketTester.js
@@ -0,0 +1,62 @@
+/* eslint-disable import/no-extraneous-dependencies */
+const WebSocket = require('ws');
+
+class WebSocketTester {
+  constructor() {
+    this.messages = []; this.receivers = [];
+  }
+
+  open(url) {
+    if (this.ws != null) return;
+    const ws = this.ws = new WebSocket(url);
+    ws.on('message', message => {
+      // console.log('Received: '+message);
+      if (this.receivers.length > 0) this.receivers.shift()(message);
+      else this.messages.push(message);
+    });
+
+    return new Promise(resolve => {
+      ws.on('open', () => {
+        resolve(true);
+      });
+    });
+  }
+
+  send(data) {
+    this.ws.send(data);
+  }
+
+  receive1() {
+    return new Promise(resolve => {
+      if (this.messages.length > 0) resolve(this.messages.shift());
+      else this.receivers.push(resolve);
+    });
+  }
+
+  receive(n) {
+    return new Promise(resolve => {
+      const messages = [];
+      for (let i = 0; i < n; i += 1) {
+        this.receive1().then(message => {
+          messages[i] = message;
+          if (i === n - 1) resolve(messages);
+        });
+      }
+    });
+  }
+
+  skip() {
+    if (this.messages.length > 0) this.messages.shift();
+    else this.receivers.push(() => {});
+  }
+
+  countUnrecived() {
+    return this.messages.length;
+  }
+
+  close() {
+    if (this.ws != null) this.ws.close();
+  }
+}
+
+module.exports = WebSocketTester;
diff --git a/manual_test_websocket/main/handler.js b/manual_test_websocket/main/handler.js
new file mode 100644
index 0000000..58c4d7d
--- /dev/null
+++ b/manual_test_websocket/main/handler.js
@@ -0,0 +1,131 @@
+const AWS = require('aws-sdk');
+
+const ddb = (() => {
+  if (process.env.IS_OFFLINE) return new AWS.DynamoDB.DocumentClient({ region: 'localhost', endpoint: 'http://localhost:8000' });
+
+  return new AWS.DynamoDB.DocumentClient();
+})();
+
+const successfullResponse = {
+  statusCode: 200,
+  body: 'Request is OK.',
+};
+
+module.exports.connect = async (event, context) => {
+  // console.log('connect:');
+  const listener = await ddb.get({ TableName:'listeners', Key:{ name:'default' } }).promise();
+
+  if (listener.Item) {
+    const timeout = new Promise(resolve => setTimeout(resolve, 100));
+    const send = sendToClient( // sendToClient won't return on AWS when client doesn't exits so we set a timeout
+      JSON.stringify({ action:'update', event:'connect', info:{ id:event.requestContext.connectionId, event:{ ...event, apiGatewayUrl:`${event.apiGatewayUrl}` }, context } }),
+      listener.Item.id,
+      newAWSApiGatewayManagementApi(event, context)).catch(() => {});
+    await Promise.race([send, timeout]);
+  }
+
+  return successfullResponse;
+};
+
+// module.export.auth = (event, context, callback) => {
+//   //console.log('auth:');
+//   const token = event.headers["Authorization"];
+
+//   if ('deny'===token) callback(null, generatePolicy('user', 'Deny', event.methodArn));
+//   else callback(null, generatePolicy('user', 'Allow', event.methodArn));;
+// };
+
+module.exports.disconnect = async (event, context) => {
+  const listener = await ddb.get({ TableName:'listeners', Key:{ name:'default' } }).promise();
+  if (listener.Item) await sendToClient(JSON.stringify({ action:'update', event:'disconnect', info:{ id:event.requestContext.connectionId, event:{ ...event, apiGatewayUrl:`${event.apiGatewayUrl}` }, context } }), listener.Item.id, newAWSApiGatewayManagementApi(event, context)).catch(() => {});
+
+  return successfullResponse;
+};
+
+module.exports.defaultHandler = async (event, context) => {
+  await sendToClient(`Error: No Supported Action in Payload '${event.body}'`, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err => console.log(err));
+
+  return successfullResponse;
+};
+
+module.exports.getClientInfo = async (event, context) => {
+  // console.log('getClientInfo:');
+  await sendToClient({ action:'update', event:'client-info', info:{ id:event.requestContext.connectionId } }, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err => console.log(err));
+
+  return successfullResponse;
+};
+
+module.exports.getCallInfo = async (event, context) => {
+  await sendToClient({ action:'update', event:'call-info', info:{ event:{ ...event, apiGatewayUrl:`${event.apiGatewayUrl}` }, context } }, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err => console.log(err));
+
+  return successfullResponse;
+};
+
+module.exports.makeError = async () => {
+  const obj = null;
+  obj.non.non = 1;
+
+  return successfullResponse;
+};
+
+module.exports.replyViaCallback = (event, context, callback) => {
+  sendToClient({ action:'update', event:'reply-via-callback' }, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err => console.log(err));
+  callback();
+};
+
+module.exports.replyErrorViaCallback = (event, context, callback) => callback('error error error');
+
+module.exports.multiCall1 = async (event, context) => {
+  await sendToClient({ action:'update', event:'made-call-1' }, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err => console.log(err));
+
+  return successfullResponse;
+};
+
+module.exports.multiCall2 = async (event, context) => {
+  await sendToClient({ action:'update', event:'made-call-2' }, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err => console.log(err));
+
+  return successfullResponse;
+};
+
+module.exports.send = async (event, context) => {
+  const action = JSON.parse(event.body);
+  const sents = [];
+  action.clients.forEach(connectionId => {
+    const sent = sendToClient(action.data, connectionId, newAWSApiGatewayManagementApi(event, context));
+    sents.push(sent);
+  });
+  const noErr = await Promise.all(sents).then(() => true).catch(() => false);
+  if (!noErr) await sendToClient('Error: Could not Send all Messages', event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context));
+
+  return successfullResponse;
+};
+
+module.exports.registerListener = async (event, context) => {
+  await ddb.put({ TableName:'listeners', Item:{ name:'default', id:event.requestContext.connectionId } }).promise();
+  await sendToClient({ action:'update', event:'register-listener', info:{ id:event.requestContext.connectionId } }, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err => console.log(err));
+
+  return successfullResponse;
+};
+
+module.exports.deleteListener = async () => {
+  await ddb.delete({ TableName:'listeners', Key:{ name:'default' } }).promise();
+
+  return successfullResponse;
+};
+
+const newAWSApiGatewayManagementApi = event => {
+  let endpoint = event.apiGatewayUrl;
+
+  if (!endpoint) endpoint = `${event.requestContext.domainName}/${event.requestContext.stage}`;
+  const apiVersion = '2018-11-29';
+
+  return new AWS.ApiGatewayManagementApi({ apiVersion, endpoint });
+};
+
+const sendToClient = (data, connectionId, apigwManagementApi) => {
+  // console.log(`sendToClient:${connectionId}`);
+  let sendee = data;
+  if (typeof data === 'object') sendee = JSON.stringify(data);
+
+  return apigwManagementApi.postToConnection({ ConnectionId: connectionId, Data: sendee }).promise();
+};
diff --git a/manual_test_websocket/manual_test_websocket_main/package-lock.json b/manual_test_websocket/main/package-lock.json
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_main/package-lock.json
rename to manual_test_websocket/main/package-lock.json
diff --git a/manual_test_websocket/manual_test_websocket_main/package.json b/manual_test_websocket/main/package.json
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_main/package.json
rename to manual_test_websocket/main/package.json
diff --git a/manual_test_websocket/manual_test_websocket_main/scripts/deploy_to_aws.sh b/manual_test_websocket/main/scripts/deploy_to_aws.sh
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_main/scripts/deploy_to_aws.sh
rename to manual_test_websocket/main/scripts/deploy_to_aws.sh
diff --git a/manual_test_websocket/manual_test_websocket_main/scripts/deploy_to_offline.sh b/manual_test_websocket/main/scripts/deploy_to_offline.sh
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_main/scripts/deploy_to_offline.sh
rename to manual_test_websocket/main/scripts/deploy_to_offline.sh
diff --git a/manual_test_websocket/manual_test_websocket_main/scripts/serverless..yml b/manual_test_websocket/main/scripts/serverless..yml
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_main/scripts/serverless..yml
rename to manual_test_websocket/main/scripts/serverless..yml
diff --git a/manual_test_websocket/manual_test_websocket_main/scripts/serverless.aws.yml b/manual_test_websocket/main/scripts/serverless.aws.yml
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_main/scripts/serverless.aws.yml
rename to manual_test_websocket/main/scripts/serverless.aws.yml
diff --git a/manual_test_websocket/manual_test_websocket_main/scripts/serverless.offline.yml b/manual_test_websocket/main/scripts/serverless.offline.yml
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_main/scripts/serverless.offline.yml
rename to manual_test_websocket/main/scripts/serverless.offline.yml
diff --git a/manual_test_websocket/manual_test_websocket_main/serverless.yml b/manual_test_websocket/main/serverless.yml
similarity index 100%
rename from manual_test_websocket/manual_test_websocket_main/serverless.yml
rename to manual_test_websocket/main/serverless.yml
diff --git a/manual_test_websocket/main/test/e2e/ws.e2e.js b/manual_test_websocket/main/test/e2e/ws.e2e.js
new file mode 100644
index 0000000..60f8a37
--- /dev/null
+++ b/manual_test_websocket/main/test/e2e/ws.e2e.js
@@ -0,0 +1,360 @@
+/* eslint-disable import/no-extraneous-dependencies */
+/* eslint-disable no-unused-expressions */
+const chai = require('chai');
+const chaiHttp = require('chai-http');
+
+chai.use(chaiHttp);
+const expect = chai.expect;
+const aws4 = require('aws4');
+const awscred = require('awscred');
+const moment = require('moment');
+
+const endpoint = process.env.npm_config_endpoint || 'ws://localhost:3001';
+const timeout = process.env.npm_config_timeout ? parseInt(process.env.npm_config_timeout) : 1000;
+const WebSocketTester = require('../support/WebSocketTester');
+
+describe('serverless', () => {
+  describe('with WebSocket support', () => {
+    let clients = []; let req = null; let cred = null;
+    const createWebSocket = async qs => {
+      const ws = new WebSocketTester();
+      let url = endpoint;
+      if (qs) url = `${endpoint}?${qs}`;
+      await ws.open(url);
+      clients.push(ws);
+
+      return ws;
+    };
+    const createClient = async qs => {
+      const ws = await createWebSocket(qs);
+      ws.send(JSON.stringify({ action:'getClientInfo' }));
+      const json = await ws.receive1();
+      const id = JSON.parse(json).info.id;
+
+      return { ws, id };
+    };
+    before(async () => {
+      req = chai.request(`${endpoint.replace('ws://', 'http://').replace('wss://', 'https://')}`).keepOpen();
+      // req=chai.request('http://localhost:3001/dev').keepOpen();
+      cred = await new Promise((resolve, reject) => {
+        awscred.loadCredentials((err, data) => {
+          if (err) reject(err); else resolve(data);
+        });
+      });
+    });
+
+    beforeEach(() => {
+      clients = [];
+    });
+    afterEach(async () => {
+      await Promise.all(clients.map(async (ws, i) => {
+        const n = ws.countUnrecived();
+
+        if (n > 0) {
+          console.log(`unreceived:[i=${i}]`);
+          (await ws.receive(n)).forEach(m => console.log(m));
+        }
+
+        expect(n).to.equal(0);
+        ws.close();
+      }));
+      clients = [];
+    });
+
+    it('should request to upgade to WebSocket when receving an HTTP request', async () => {
+      const req = chai.request(`${endpoint.replace('ws://', 'http://').replace('wss://', 'https://')}`).keepOpen();
+      let res = await req.get(`/${Date.now()}`);// .set('Authorization', user.accessToken);
+
+      expect(res).to.have.status(426);
+
+      res = await req.get(`/${Date.now()}/${Date.now()}`);// .set('Authorization', user.accessToken);
+
+      expect(res).to.have.status(426);
+    }).timeout(timeout);
+
+    it('should open a WebSocket', async () => {
+      const ws = await createWebSocket();
+      expect(ws).not.to.be.undefined;
+    }).timeout(timeout);
+
+    it('should receive client connection info', async () => {
+      const ws = await createWebSocket();
+      ws.send(JSON.stringify({ action:'getClientInfo' }));
+      const clientInfo = JSON.parse(await ws.receive1());
+
+      expect(clientInfo).to.deep.equal({ action:'update', event:'client-info', info:{ id:clientInfo.info.id } });
+    }).timeout(timeout);
+
+    it('should call default handler when no such action exists', async () => {
+      const ws = await createWebSocket();
+      const payload = JSON.stringify({ action:`action${Date.now()}` });
+      ws.send(payload);
+
+      expect(await ws.receive1()).to.equal(`Error: No Supported Action in Payload '${payload}'`);
+    }).timeout(timeout);
+
+    it('should call default handler when no action provided', async () => {
+      const ws = await createWebSocket();
+      ws.send(JSON.stringify({ hello:'world' }));
+
+      expect(await ws.receive1()).to.equal('Error: No Supported Action in Payload \'{"hello":"world"}\'');
+    }).timeout(timeout);
+
+    it('should send & receive data', async () => {
+      const c1 = await createClient();
+      const c2 = await createClient();
+      c1.ws.send(JSON.stringify({ action:'send', data:'Hello World!', clients:[c1.id, c2.id] }));
+
+      expect(await c1.ws.receive1()).to.equal('Hello World!');
+      expect(await c2.ws.receive1()).to.equal('Hello World!');
+    }).timeout(timeout);
+
+    it('should respond when having an internal server error', async () => {
+      const conn = await createClient();
+      conn.ws.send(JSON.stringify({ action:'makeError' }));
+      const res = JSON.parse(await conn.ws.receive1());
+
+      expect(res).to.deep.equal({ message:'Internal server error', connectionId:conn.id, requestId:res.requestId });
+    }).timeout(timeout);
+
+    it('should respond via callback', async () => {
+      const ws = await createWebSocket();
+      ws.send(JSON.stringify({ action:'replyViaCallback' }));
+      const res = JSON.parse(await ws.receive1());
+      expect(res).to.deep.equal({ action:'update', event:'reply-via-callback' });
+    }).timeout(timeout);
+
+    it('should respond with error when calling callback(error)', async () => {
+      const conn = await createClient();
+      conn.ws.send(JSON.stringify({ action:'replyErrorViaCallback' }));
+      const res = JSON.parse(await conn.ws.receive1());
+      expect(res).to.deep.equal({ message:'Internal server error', connectionId:conn.id, requestId:res.requestId });
+    }).timeout(timeout);
+
+    it('should respond with only the last action when there are more than one in the serverless.yml file', async () => {
+      const ws = await createWebSocket();
+      ws.send(JSON.stringify({ action:'makeMultiCalls' }));
+      const res = JSON.parse(await ws.receive1());
+
+      expect(res).to.deep.equal({ action:'update', event:'made-call-2' });
+    }).timeout(timeout);
+
+    it('should not send to non existing client', async () => {
+      const c1 = await createClient();
+      c1.ws.send(JSON.stringify({ action:'send', data:'Hello World!', clients:['non-existing-id'] }));
+
+      expect(await c1.ws.receive1()).to.equal('Error: Could not Send all Messages');
+    }).timeout(timeout);
+
+    it('should connect & disconnect', async () => {
+      const ws = await createWebSocket();
+      await ws.send(JSON.stringify({ action:'registerListener' }));
+      await ws.receive1();
+
+      const c1 = await createClient();
+      const connect1 = JSON.parse(await ws.receive1()); delete connect1.info.event; delete delete connect1.info.context;
+      expect(connect1).to.deep.equal({ action:'update', event:'connect', info:{ id:c1.id } });
+
+      const c2 = await createClient();
+      const connect2 = JSON.parse(await ws.receive1()); delete connect2.info.event; delete delete connect2.info.context;
+      expect(connect2).to.deep.equal({ action:'update', event:'connect', info:{ id:c2.id } });
+
+      c2.ws.close();
+      const disconnect2 = JSON.parse(await ws.receive1()); delete disconnect2.info.event; delete delete disconnect2.info.context;
+      expect(disconnect2).to.deep.equal({ action:'update', event:'disconnect', info:{ id:c2.id } });
+
+      const c3 = await createClient();
+      const connect3 = JSON.parse(await ws.receive1()); delete connect3.info.event; delete delete connect3.info.context;
+      expect(connect3).to.deep.equal({ action:'update', event:'connect', info:{ id:c3.id } });
+
+      c1.ws.close();
+      const disconnect1 = JSON.parse(await ws.receive1()); delete disconnect1.info.event; delete delete disconnect1.info.context;
+      expect(disconnect1).to.deep.equal({ action:'update', event:'disconnect', info:{ id:c1.id } });
+
+      c3.ws.close();
+      const disconnect3 = JSON.parse(await ws.receive1()); delete disconnect3.info.event; delete delete disconnect3.info.context;
+      expect(disconnect3).to.deep.equal({ action:'update', event:'disconnect', info:{ id:c3.id } });
+    }).timeout(timeout);
+
+    const createExpectedEvent = (connectionId, action, eventType, actualEvent) => {
+      const url = new URL(endpoint);
+      const expected = {
+        apiGatewayUrl: `${actualEvent.apiGatewayUrl}`,
+        isBase64Encoded: false,
+        requestContext: {
+          apiId: actualEvent.requestContext.apiId,
+          connectedAt: actualEvent.requestContext.connectedAt,
+          connectionId: `${connectionId}`,
+          domainName: url.hostname,
+          eventType,
+          extendedRequestId: actualEvent.requestContext.extendedRequestId,
+          identity: {
+            accessKey: null,
+            accountId: null,
+            caller: null,
+            cognitoAuthenticationProvider: null,
+            cognitoAuthenticationType: null,
+            cognitoIdentityId: null,
+            cognitoIdentityPoolId: null,
+            principalOrgId: null,
+            sourceIp: actualEvent.requestContext.identity.sourceIp,
+            user: null,
+            userAgent: null,
+            userArn: null,
+          },
+          messageDirection: 'IN',
+          messageId: actualEvent.requestContext.messageId,
+          requestId: actualEvent.requestContext.requestId,
+          requestTime: actualEvent.requestContext.requestTime,
+          requestTimeEpoch: actualEvent.requestContext.requestTimeEpoch,
+          routeKey: action,
+          stage: actualEvent.requestContext.stage,
+        },
+      };
+
+      return expected;
+    };
+
+    const createExpectedContext = actualContext => {
+      const expected = {
+        awsRequestId: actualContext.awsRequestId,
+        callbackWaitsForEmptyEventLoop: true,
+        functionName: actualContext.functionName,
+        functionVersion: '$LATEST',
+        invokedFunctionArn: actualContext.invokedFunctionArn,
+        invokeid: actualContext.invokeid,
+        logGroupName: actualContext.logGroupName,
+        logStreamName: actualContext.logStreamName,
+        memoryLimitInMB: actualContext.memoryLimitInMB,
+      };
+
+      return expected;
+    };
+
+    const createExpectedConnectHeaders = actualHeaders => {
+      const url = new URL(endpoint);
+      const expected = {
+        Host: url.hostname,
+        'Sec-WebSocket-Extensions': actualHeaders['Sec-WebSocket-Extensions'],
+        'Sec-WebSocket-Key': actualHeaders['Sec-WebSocket-Key'],
+        'Sec-WebSocket-Version': actualHeaders['Sec-WebSocket-Version'],
+        'X-Amzn-Trace-Id': actualHeaders['X-Amzn-Trace-Id'],
+        'X-Forwarded-For': actualHeaders['X-Forwarded-For'],
+        'X-Forwarded-Port': `${url.port || 443}`,
+        'X-Forwarded-Proto': `${url.protocol.replace('ws', 'http').replace('wss', 'https').replace(':', '')}`,
+      };
+
+      return expected;
+    };
+
+    const createExpectedDisconnectHeaders = () => {
+      const url = new URL(endpoint);
+      const expected = {
+        Host: url.hostname,
+        'x-api-key': '',
+        'x-restapi': '',
+      };
+
+      return expected;
+    };
+
+    const createExpectedConnectMultiValueHeaders = actualHeaders => {
+      const expected = createExpectedConnectHeaders(actualHeaders);
+      Object.keys(expected).forEach(key => {
+        expected[key] = [expected[key]];
+      });
+
+      return expected;
+    };
+
+    const createExpectedDisconnectMultiValueHeaders = actualHeaders => {
+      const expected = createExpectedDisconnectHeaders(actualHeaders);
+      Object.keys(expected).forEach(key => {
+        expected[key] = [expected[key]];
+      });
+
+      return expected;
+    };
+
+    it('should receive correct call info', async () => {
+      const ws = await createWebSocket();
+      await ws.send(JSON.stringify({ action:'registerListener' }));
+      await ws.receive1();
+
+      // connect
+      const c = await createClient();
+      const connect = JSON.parse(await ws.receive1());
+      let now = Date.now();
+      let expectedCallInfo = { id:c.id, event:{ headers:createExpectedConnectHeaders(connect.info.event.headers), multiValueHeaders:createExpectedConnectMultiValueHeaders(connect.info.event.headers), ...createExpectedEvent(c.id, '$connect', 'CONNECT', connect.info.event) }, context:createExpectedContext(connect.info.context) };
+
+      expect(connect).to.deep.equal({ action:'update', event:'connect', info:expectedCallInfo });
+      expect(connect.info.event.requestContext.requestTimeEpoch).to.be.within(connect.info.event.requestContext.connectedAt - 10, connect.info.event.requestContext.requestTimeEpoch + 10);
+      expect(connect.info.event.requestContext.connectedAt).to.be.within(now - timeout, now);
+      expect(connect.info.event.requestContext.requestTimeEpoch).to.be.within(now - timeout, now);
+      expect(moment.utc(connect.info.event.requestContext.requestTime, 'D/MMM/YYYY:H:m:s Z').toDate().getTime()).to.be.within(now - timeout, now);
+
+      if (endpoint.startsWith('ws://locahost')) {
+        expect(connect.info.event.apiGatewayUrl).to.equal(endpoint.replace('ws://', 'http://').replace('wss://', 'https://'));
+        expect(connect.info.event.headers['X-Forwarded-For']).to.be.equal('127.0.0.1');
+      }
+
+      // getCallInfo
+      c.ws.send(JSON.stringify({ action:'getCallInfo' }));
+      const callInfo = JSON.parse(await c.ws.receive1());
+      now = Date.now();
+      expectedCallInfo = { event:{ body: '{"action":"getCallInfo"}', ...createExpectedEvent(c.id, 'getCallInfo', 'MESSAGE', callInfo.info.event) }, context:createExpectedContext(callInfo.info.context) };
+
+      expect(callInfo).to.deep.equal({ action:'update', event:'call-info', info:expectedCallInfo });
+      expect(callInfo.info.event.requestContext.connectedAt).to.be.lt(callInfo.info.event.requestContext.requestTimeEpoch);
+      expect(callInfo.info.event.requestContext.connectedAt).to.be.within(now - timeout, now);
+      expect(callInfo.info.event.requestContext.requestTimeEpoch).to.be.within(now - timeout, now);
+      expect(moment.utc(callInfo.info.event.requestContext.requestTime, 'D/MMM/YYYY:H:m:s Z').toDate().getTime()).to.be.within(now - timeout, now);
+      if (endpoint.startsWith('ws://locahost')) expect(callInfo.info.event.apiGatewayUrl).to.equal(endpoint.replace('ws://', 'http://').replace('wss://', 'https://'));
+
+      // disconnect
+      c.ws.close();
+      const disconnect = JSON.parse(await ws.receive1());
+      now = Date.now();
+      expectedCallInfo = { id:c.id, event:{ headers:createExpectedDisconnectHeaders(disconnect.info.event.headers), multiValueHeaders:createExpectedDisconnectMultiValueHeaders(disconnect.info.event.headers), ...createExpectedEvent(c.id, '$disconnect', 'DISCONNECT', disconnect.info.event) }, context:createExpectedContext(disconnect.info.context) };
+
+      expect(disconnect).to.deep.equal({ action:'update', event:'disconnect', info:expectedCallInfo });
+    }).timeout(timeout);
+
+    it('should be able to parse query string', async () => {
+      const now = `${Date.now()}`;
+      const ws = await createWebSocket();
+      await ws.send(JSON.stringify({ action:'registerListener' }));
+      await ws.receive1();
+
+      await createClient();
+      await createClient(`now=${now}&before=123456789`);
+
+      expect(JSON.parse(await ws.receive1()).info.event.queryStringParameters).to.be.undefined;
+      expect(JSON.parse(await ws.receive1()).info.event.queryStringParameters).to.deep.equal({ now, before:'123456789' });
+    }).timeout(timeout);
+
+    it('should be able to receive messages via REST API', async () => {
+      await createClient();
+      const c2 = await createClient();
+      const url = new URL(endpoint);
+      const signature = { service: 'execute-api', host:url.host, path:`${url.pathname}/@connections/${c2.id}`, method: 'POST', body:'Hello World!', headers:{ 'Content-Type':'text/plain'/* 'application/text' */ } };
+      aws4.sign(signature, { accessKeyId: cred.accessKeyId, secretAccessKey: cred.secretAccessKey });
+      const res = await req.post(signature.path.replace(url.pathname, '')).set('X-Amz-Date', signature.headers['X-Amz-Date']).set('Authorization', signature.headers.Authorization).set('Content-Type', signature.headers['Content-Type'])
+.send('Hello World!');
+
+      expect(res).to.have.status(200);
+      expect(await c2.ws.receive1()).to.equal('Hello World!');
+    }).timeout(timeout);
+
+    it('should receive error code when sending to non existing client via REST API', async () => {
+      const c = 'aJz0Md6VoAMCIbQ=';
+      const url = new URL(endpoint);
+      const signature = { service: 'execute-api', host:url.host, path:`${url.pathname}/@connections/${c}`, method: 'POST', body:'Hello World!', headers:{ 'Content-Type':'text/plain'/* 'application/text' */ } };
+      aws4.sign(signature, { accessKeyId: cred.accessKeyId, secretAccessKey: cred.secretAccessKey });
+      const res = await req.post(signature.path.replace(url.pathname, '')).set('X-Amz-Date', signature.headers['X-Amz-Date']).set('Authorization', signature.headers.Authorization).set('Content-Type', signature.headers['Content-Type'])
+.send('Hello World!');
+
+      expect(res).to.have.status(410);
+    }).timeout(timeout);
+  });
+});
diff --git a/manual_test_websocket/main/test/support/WebSocketTester.js b/manual_test_websocket/main/test/support/WebSocketTester.js
new file mode 100644
index 0000000..aaeff5a
--- /dev/null
+++ b/manual_test_websocket/main/test/support/WebSocketTester.js
@@ -0,0 +1,62 @@
+/* eslint-disable import/no-extraneous-dependencies */
+const WebSocket = require('ws');
+
+class WebSocketTester {
+  constructor() {
+    this.messages = []; this.receivers = [];
+  }
+
+  open(url) {
+    if (this.ws != null) return;
+    const ws = this.ws = new WebSocket(url);
+    ws.on('message', message => {
+      // console.log('Received: '+message);
+      if (this.receivers.length > 0) this.receivers.shift()(message);
+      else this.messages.push(message);
+    });
+
+    return new Promise(resolve => {
+      ws.on('open', () => {
+        resolve(true);
+      });
+    });
+  }
+
+  send(data) {
+    this.ws.send(data);
+  }
+
+  receive1() {
+    return new Promise(resolve => {
+      if (this.messages.length > 0) resolve(this.messages.shift());
+      else this.receivers.push(resolve);
+    });
+  }
+
+  receive(n) {
+    return new Promise(resolve => {
+      const messages = [];
+      for (let i = 0; i < n; i += 1) {
+        this.receive1().then(message => {
+          messages[i] = message;
+          if (i === n - 1) resolve(messages);
+        });
+      }
+    });
+  }
+
+  skip() {
+    if (this.messages.length > 0) this.messages.shift();
+    else this.receivers.push(() => {});
+  }
+
+  countUnrecived() {
+    return this.messages.length;
+  }
+
+  close() {
+    if (this.ws != null) this.ws.close();
+  }
+}
+
+module.exports = WebSocketTester;
diff --git a/manual_test_websocket/manual_test_websocket_RouteSelection/handler.js b/manual_test_websocket/manual_test_websocket_RouteSelection/handler.js
deleted file mode 100644
index e8da78f..0000000
--- a/manual_test_websocket/manual_test_websocket_RouteSelection/handler.js
+++ /dev/null
@@ -1,37 +0,0 @@
-'use strict';
-
-const AWS = require('aws-sdk');
-
-
-const successfullResponse = {
-  statusCode: 200,
-  body: 'Request is OK.'
-};
-
-const errorResponse = {
-  statusCode: 400,
-  body: 'Request is not OK.'
-};
-
-module.exports.echo = async (event, context) => {
-  const action = JSON.parse(event.body);
-  
-  await sendToClient(action.message, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context));
-  return successfullResponse; 
-};
-
-const newAWSApiGatewayManagementApi=(event, context)=>{
-  let endpoint=event.apiGatewayUrl;
-
-  if (!endpoint) endpoint = event.requestContext.domainName+'/'+event.requestContext.stage;
-  const apiVersion='2018-11-29';
-  return new AWS.ApiGatewayManagementApi({ apiVersion, endpoint });
-};
-
-const sendToClient = (data, connectionId, apigwManagementApi) => {
-  // console.log(`sendToClient:${connectionId}`);
-  let sendee=data;
-  if ('object'==typeof data) sendee=JSON.stringify(data);
-
-  return apigwManagementApi.postToConnection({ConnectionId: connectionId, Data: sendee}).promise();
-};
diff --git a/manual_test_websocket/manual_test_websocket_RouteSelection/test/e2e/ws.e2e.js b/manual_test_websocket/manual_test_websocket_RouteSelection/test/e2e/ws.e2e.js
deleted file mode 100644
index a565936..0000000
--- a/manual_test_websocket/manual_test_websocket_RouteSelection/test/e2e/ws.e2e.js
+++ /dev/null
@@ -1,53 +0,0 @@
-const chai = require('chai');
-const expect = chai.expect;
-const endpoint = process.env.npm_config_endpoint||'ws://localhost:3005';
-const timeout = process.env.npm_config_timeout?parseInt(process.env.npm_config_timeout):1000;
-const WebSocketTester=require('../support/WebSocketTester');
-
-describe('serverless', ()=>{
-  describe('with WebSocket support', ()=>{
-    let clients=[]; let req=null; let cred=null;
-    const createWebSocket=async (qs)=>{
-      const ws=new WebSocketTester();
-      let url=endpoint;
-      if (qs) url=`${endpoint}?${qs}`;
-      await ws.open(url);
-      clients.push(ws);
-      return ws;
-    };
-    const createClient=async (qs)=>{
-      const ws=await createWebSocket(qs);
-      ws.send(JSON.stringify({action:'getClientInfo'}));
-      const json=await ws.receive1();
-      const id=JSON.parse(json).info.id;
-      return {ws, id};
-    };
-    
-    beforeEach(()=>{
-      clients=[];
-    });
-    afterEach(async ()=>{
-      await Promise.all(clients.map(async (ws, i)=>{
-        const n=ws.countUnrecived();
-
-        if (n>0) {
-          console.log(`unreceived:[i=${i}]`);
-          (await ws.receive(n)).forEach(m=>console.log(m));
-        }
-        expect(n).to.equal(0);
-        ws.close();
-      }));
-      clients=[];
-    });
-
-    it(`should call action 'echo' handler located at service.do`, async ()=>{
-      const ws=await createWebSocket();
-      const now=""+Date.now();
-      const payload=JSON.stringify({service:{do:'echo'}, message:now});
-      ws.send(payload);
-      expect(await ws.receive1()).to.equal(`${now}`);
-    }).timeout(timeout);
-
-    
-  });
-});
\ No newline at end of file
diff --git a/manual_test_websocket/manual_test_websocket_RouteSelection/test/support/WebSocketTester.js b/manual_test_websocket/manual_test_websocket_RouteSelection/test/support/WebSocketTester.js
deleted file mode 100644
index d5e8005..0000000
--- a/manual_test_websocket/manual_test_websocket_RouteSelection/test/support/WebSocketTester.js
+++ /dev/null
@@ -1,62 +0,0 @@
-'use strict';
-
-const WebSocket = require('ws');
-
-class WebSocketTester {
-  constructor() {
-    this.messages=[]; this.receivers=[];
-  }
-
-  open(url) {
-    if (null!=this.ws) return;
-    const ws=this.ws=new WebSocket(url);
-    ws.on('message', (message)=>{
-      // console.log('Received: '+message);
-      if (0<this.receivers.length) this.receivers.shift()(message);
-      else this.messages.push(message);
-    });
-    return new Promise((resolve/*, reject*/)=> {
-      ws.on('open', ()=>{
-        resolve(true);
-      });
-    });
-  }
-
-  send(data) {
-    this.ws.send(data);
-  }
-
-  receive1() {
-    return new Promise((resolve/*, reject*/)=>{
-      if (0<this.messages.length) resolve(this.messages.shift());
-      else this.receivers.push(resolve);
-    });
-  }
-
-  receive(n) {
-    return new Promise((resolve/*, reject*/)=>{
-      const messages=[];
-      for (let i=0; i<n; i+=1) {
-        this.receive1().then((message)=>{
-          messages[i]=message;
-          if (i===n-1) resolve(messages);
-        });
-      }
-    });
-  }
-
-  skip() {
-    if (0<this.messages.length) this.messages.shift();
-    else this.receivers.push(()=>{});
-  }
-
-  countUnrecived() {
-    return this.messages.length;
-  }
-
-  close() {
-    if (null!=this.ws) this.ws.close();
-  }
-};
-
-module.exports=WebSocketTester;
diff --git a/manual_test_websocket/manual_test_websocket_main/handler.js b/manual_test_websocket/manual_test_websocket_main/handler.js
deleted file mode 100644
index 7ada0f0..0000000
--- a/manual_test_websocket/manual_test_websocket_main/handler.js
+++ /dev/null
@@ -1,150 +0,0 @@
-'use strict';
-
-const AWS = require('aws-sdk');
-const ddb = (()=>{
-  if (process.env.IS_OFFLINE) return new AWS.DynamoDB.DocumentClient({region: "localhost", endpoint: "http://localhost:8000"});
-  return new AWS.DynamoDB.DocumentClient();
-})();
-
-
-const successfullResponse = {
-  statusCode: 200,
-  body: 'Request is OK.'
-};
-
-const errorResponse = {
-  statusCode: 400,
-  body: 'Request is not OK.'
-};
-
-// const generatePolicy = function(principalId, effect, resource) {
-//   const authResponse = {};
-//   authResponse.principalId = principalId;
-//   if (effect && resource) {
-//       const policyDocument = {};
-//       policyDocument.Version = '2012-10-17';
-//       policyDocument.Statement = [];
-//       const statementOne = {};
-//       statementOne.Action = 'execute-api:Invoke';
-//       statementOne.Effect = effect;
-//       statementOne.Resource = resource;
-//       policyDocument.Statement[0] = statementOne;
-//       authResponse.policyDocument = policyDocument;
-//   }
-//   return authResponse;
-// };
-
-// module.exports.http = async (event, context) => {
-//   return successfullResponse; 
-// };
-
-module.exports.connect = async (event, context) => {
-  // console.log('connect:');
-  const listener=await ddb.get({TableName:'listeners', Key:{name:'default'}}).promise();
-
-  if (listener.Item) {
-    const timeout=new Promise((resolve) => setTimeout(resolve,100));
-    const send=sendToClient( // sendToClient won't return on AWS when client doesn't exits so we set a timeout
-      JSON.stringify({action:'update', event:'connect', info:{id:event.requestContext.connectionId, event:{...event,  apiGatewayUrl:`${event.apiGatewayUrl}`}, context}}), 
-      listener.Item.id, 
-      newAWSApiGatewayManagementApi(event, context)).catch(()=>{});
-    await Promise.race([send, timeout]);
-  }
-  return successfullResponse; 
-};
-
-// module.export.auth = (event, context, callback) => {
-//   //console.log('auth:');
-//   const token = event.headers["Authorization"];
-  
-//   if ('deny'===token) callback(null, generatePolicy('user', 'Deny', event.methodArn));
-//   else callback(null, generatePolicy('user', 'Allow', event.methodArn));;
-// };
-
-module.exports.disconnect = async (event, context) => {
-  const listener=await ddb.get({TableName:'listeners', Key:{name:'default'}}).promise();
-  if (listener.Item) await sendToClient(JSON.stringify({action:'update', event:'disconnect', info:{id:event.requestContext.connectionId, event:{...event,  apiGatewayUrl:`${event.apiGatewayUrl}`}, context}}), listener.Item.id, newAWSApiGatewayManagementApi(event, context)).catch(()=>{});
-  return successfullResponse; 
-};
-
-module.exports.defaultHandler = async (event, context) => {
-  await sendToClient(`Error: No Supported Action in Payload '${event.body}'`, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err=>console.log(err));
-  return successfullResponse; 
-};
-
-module.exports.getClientInfo = async (event, context) => {
-  // console.log('getClientInfo:');
-  await sendToClient({action:'update', event:'client-info', info:{id:event.requestContext.connectionId}}, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err=>console.log(err));
-  return successfullResponse; 
-};
-
-module.exports.getCallInfo = async (event, context) => {
-  await sendToClient({action:'update', event:'call-info', info:{event:{...event,  apiGatewayUrl:`${event.apiGatewayUrl}`}, context}}, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err=>console.log(err));
-  return successfullResponse; 
-};
-
-module.exports.makeError = async (event, context) => {
-  const obj=null;
-  obj.non.non=1;
-  return successfullResponse; 
-};
-
-module.exports.replyViaCallback = (event, context, callback) => {
-  sendToClient({action:'update', event:'reply-via-callback'}, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err=>console.log(err));
-  callback();
-};
-
-module.exports.replyErrorViaCallback = (event, context, callback) => {
-  return callback("error error error");
-};
-
-module.exports.multiCall1 = async (event, context) => {
-  await sendToClient({action:'update', event:'made-call-1'}, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err=>console.log(err));
-  return successfullResponse; 
-};
-
-module.exports.multiCall2 = async (event, context) => {
-  await sendToClient({action:'update', event:'made-call-2'}, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err=>console.log(err));
-  return successfullResponse; 
-};
-
-
-module.exports.send = async (event, context) => {
-  const action = JSON.parse(event.body);
-  const sents=[];
-  action.clients.forEach((connectionId)=>{ 
-    const sent=sendToClient(action.data, connectionId, newAWSApiGatewayManagementApi(event, context));
-    sents.push(sent);
-  });
-  const noErr=await Promise.all(sents).then(()=>true).catch(()=>false);
-  if (!noErr) await sendToClient('Error: Could not Send all Messages', event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context));
-  return successfullResponse; 
-};
-
-module.exports.registerListener = async (event, context) => {
-  await ddb.put({TableName:'listeners', Item:{name:'default', id:event.requestContext.connectionId}}).promise();
-  await sendToClient({action:'update', event:'register-listener', info:{id:event.requestContext.connectionId}}, event.requestContext.connectionId, newAWSApiGatewayManagementApi(event, context)).catch(err=>console.log(err));
-  return successfullResponse; 
-};
-
-module.exports.deleteListener = async (event, context) => {
-  await ddb.delete({TableName:'listeners', Key:{name:'default'}}).promise();
-
-  return successfullResponse;  
-};
-
-const newAWSApiGatewayManagementApi=(event, context)=>{
-  let endpoint=event.apiGatewayUrl;
-
-  if (!endpoint) endpoint = event.requestContext.domainName+'/'+event.requestContext.stage;
-  const apiVersion='2018-11-29';
-  return new AWS.ApiGatewayManagementApi({ apiVersion, endpoint });
-};
-
-const sendToClient = (data, connectionId, apigwManagementApi) => {
-  // console.log(`sendToClient:${connectionId}`);
-  let sendee=data;
-  if ('object'==typeof data) sendee=JSON.stringify(data);
-
-  return apigwManagementApi.postToConnection({ConnectionId: connectionId, Data: sendee}).promise();
-};
diff --git a/manual_test_websocket/manual_test_websocket_main/test/e2e/ws.e2e.js b/manual_test_websocket/manual_test_websocket_main/test/e2e/ws.e2e.js
deleted file mode 100644
index d8db0b7..0000000
--- a/manual_test_websocket/manual_test_websocket_main/test/e2e/ws.e2e.js
+++ /dev/null
@@ -1,342 +0,0 @@
-const chai = require('chai');
-const chaiHttp = require('chai-http');
-chai.use(chaiHttp);
-const expect = chai.expect;
-const aws4  = require('aws4');
-const awscred = require('awscred');
-const moment = require('moment');
-const endpoint = process.env.npm_config_endpoint||'ws://localhost:3001';
-const timeout = process.env.npm_config_timeout?parseInt(process.env.npm_config_timeout):1000;
-const WebSocketTester=require('../support/WebSocketTester');
-
-describe('serverless', ()=>{
-  describe('with WebSocket support', ()=>{
-    let clients=[]; let req=null; let cred=null;
-    const createWebSocket=async (qs)=>{
-      const ws=new WebSocketTester();
-      let url=endpoint;
-      if (qs) url=`${endpoint}?${qs}`;
-      await ws.open(url);
-      clients.push(ws);
-      return ws;
-    };
-    const createClient=async (qs)=>{
-      const ws=await createWebSocket(qs);
-      ws.send(JSON.stringify({action:'getClientInfo'}));
-      const json=await ws.receive1();
-      const id=JSON.parse(json).info.id;
-      return {ws, id};
-    };
-    before(async ()=>{
-      req=chai.request(`${endpoint.replace('ws://', 'http://').replace('wss://', 'https://')}`).keepOpen();
-      // req=chai.request('http://localhost:3001/dev').keepOpen();
-      cred=await new Promise((resolve, reject)=>{
-        awscred.loadCredentials(function(err, data) { if (err) reject(err); else resolve(data); });
-      });
-    });
-    
-    beforeEach(()=>{
-      clients=[];
-    });
-    afterEach(async ()=>{
-      await Promise.all(clients.map(async (ws, i)=>{
-        const n=ws.countUnrecived();
-
-        if (n>0) {
-          console.log(`unreceived:[i=${i}]`);
-          (await ws.receive(n)).forEach(m=>console.log(m));
-        }
-        expect(n).to.equal(0);
-        ws.close();
-      }));
-      clients=[];
-    });
-
-    it('should request to upgade to WebSocket when receving an HTTP request',  async ()=>{
-      const req=chai.request(`${endpoint.replace('ws://', 'http://').replace('wss://', 'https://')}`).keepOpen();
-      let res=await req.get(`/${Date.now()}`);//.set('Authorization', user.accessToken);
-      expect(res).to.have.status(426);
-      res=await req.get(`/${Date.now()}/${Date.now()}`);//.set('Authorization', user.accessToken);
-      expect(res).to.have.status(426);
-    }).timeout(timeout);
-
-    it('should open a WebSocket', async ()=>{
-      const ws=await createWebSocket();
-      expect(ws).not.to.be.undefined;
-    }).timeout(timeout);
-
-    it('should receive client connection info', async ()=>{
-      const ws=await createWebSocket();
-      ws.send(JSON.stringify({action:'getClientInfo'}));
-      const clientInfo=JSON.parse(await ws.receive1());
-      expect(clientInfo).to.deep.equal({action:'update', event:'client-info', info:{id:clientInfo.info.id}});
-    }).timeout(timeout);
-
-    it('should call default handler when no such action exists', async ()=>{
-      const ws=await createWebSocket();
-      const payload=JSON.stringify({action:'action'+Date.now()});
-      ws.send(payload);
-      expect(await ws.receive1()).to.equal(`Error: No Supported Action in Payload '${payload}'`);
-    }).timeout(timeout);
-
-    it('should call default handler when no action provided', async ()=>{
-      const ws=await createWebSocket();
-      ws.send(JSON.stringify({hello:'world'}));
-      expect(await ws.receive1()).to.equal(`Error: No Supported Action in Payload '{"hello":"world"}'`);
-    }).timeout(timeout);
-
-    it('should send & receive data', async ()=>{
-      const c1=await createClient();
-      const c2=await createClient();
-      const c3=await createClient();
-      c1.ws.send(JSON.stringify({action:'send', data:'Hello World!', clients:[c1.id, c3.id]}));
-      expect(await c1.ws.receive1()).to.equal('Hello World!');
-      expect(await c3.ws.receive1()).to.equal('Hello World!');
-    }).timeout(timeout);
-
-    it('should respond when having an internal server error', async ()=>{
-      const conn=await createClient();
-      conn.ws.send(JSON.stringify({action:'makeError'}));
-      const res=JSON.parse(await conn.ws.receive1());
-      expect(res).to.deep.equal({message:'Internal server error', connectionId:conn.id, requestId:res.requestId});
-    }).timeout(timeout);
-
-    it('should respond via callback', async ()=>{
-      const ws=await createWebSocket();
-      ws.send(JSON.stringify({action:'replyViaCallback'}));
-      const res=JSON.parse(await ws.receive1());
-      expect(res).to.deep.equal({action:'update', event:'reply-via-callback'});
-    }).timeout(timeout);
-
-    it('should respond with error when calling callback(error)', async ()=>{
-      const conn=await createClient();
-      conn.ws.send(JSON.stringify({action:'replyErrorViaCallback'}));
-      const res=JSON.parse(await conn.ws.receive1());
-      expect(res).to.deep.equal({message:'Internal server error', connectionId:conn.id, requestId:res.requestId});
-    }).timeout(timeout);
-
-    it('should respond with only the last action when there are more than one in the serverless.yml file', async ()=>{
-      const ws=await createWebSocket();
-      ws.send(JSON.stringify({action:'makeMultiCalls'}));
-      const res=JSON.parse(await ws.receive1());
-      expect(res).to.deep.equal({action:'update', event:'made-call-2'});
-    }).timeout(timeout);
-
-    it('should not send to non existing client', async ()=>{
-      const c1=await createClient();
-      c1.ws.send(JSON.stringify({action:'send', data:'Hello World!', clients:["non-existing-id"]}));
-      expect(await c1.ws.receive1()).to.equal('Error: Could not Send all Messages');
-    }).timeout(timeout);
-
-    it('should connect & disconnect', async ()=>{
-      const ws=await createWebSocket();
-      await ws.send(JSON.stringify({action:'registerListener'}));
-      await ws.receive1();
-
-      const c1=await createClient();
-      const connect1 = JSON.parse(await ws.receive1()); delete connect1.info.event; delete delete connect1.info.context;
-      expect(connect1).to.deep.equal({action:'update', event:'connect', info:{id:c1.id}});
-
-      const c2=await createClient();
-      const connect2 = JSON.parse(await ws.receive1()); delete connect2.info.event; delete delete connect2.info.context;
-      expect(connect2).to.deep.equal({action:'update', event:'connect', info:{id:c2.id}});
-
-      c2.ws.close();
-      const disconnect2 = JSON.parse(await ws.receive1()); delete disconnect2.info.event; delete delete disconnect2.info.context;
-      expect(disconnect2).to.deep.equal({action:'update', event:'disconnect', info:{id:c2.id}});
-
-      const c3=await createClient();
-      const connect3 = JSON.parse(await ws.receive1()); delete connect3.info.event; delete delete connect3.info.context;
-      expect(connect3).to.deep.equal({action:'update', event:'connect', info:{id:c3.id}});
-
-      c1.ws.close();
-      const disconnect1 = JSON.parse(await ws.receive1()); delete disconnect1.info.event; delete delete disconnect1.info.context;
-      expect(disconnect1).to.deep.equal({action:'update', event:'disconnect', info:{id:c1.id}});
-
-      c3.ws.close();
-      const disconnect3 = JSON.parse(await ws.receive1()); delete disconnect3.info.event; delete delete disconnect3.info.context;
-      expect(disconnect3).to.deep.equal({action:'update', event:'disconnect', info:{id:c3.id}});
-    }).timeout(timeout);
-
-    const createExpectedEvent=(connectionId, action, eventType, actualEvent)=>{
-      const url=new URL(endpoint);
-      const expected={
-        apiGatewayUrl: `${actualEvent.apiGatewayUrl}`,
-        isBase64Encoded: false,
-        requestContext: {
-          apiId: actualEvent.requestContext.apiId,
-          connectedAt: actualEvent.requestContext.connectedAt,
-          connectionId: `${connectionId}`,
-          domainName: url.hostname,
-          eventType,
-          extendedRequestId: actualEvent.requestContext.extendedRequestId,
-          identity: {
-            accessKey: null,
-            accountId: null,
-            caller: null,
-            cognitoAuthenticationProvider: null,
-            cognitoAuthenticationType: null,
-            cognitoIdentityId: null,
-            cognitoIdentityPoolId: null,
-            principalOrgId: null,
-            sourceIp: actualEvent.requestContext.identity.sourceIp,
-            user: null,
-            userAgent: null,
-            userArn: null,
-          },
-          messageDirection: 'IN',
-          messageId: actualEvent.requestContext.messageId,
-          requestId: actualEvent.requestContext.requestId,
-          requestTime: actualEvent.requestContext.requestTime,
-          requestTimeEpoch: actualEvent.requestContext.requestTimeEpoch,
-          routeKey: action,
-          stage: actualEvent.requestContext.stage,
-        },
-      };
-
-      return expected;
-    };
-
-    const createExpectedContext=(actualContext)=>{
-      const expected={
-          awsRequestId: actualContext.awsRequestId,
-          callbackWaitsForEmptyEventLoop: true,
-          functionName: actualContext.functionName,
-          functionVersion: '$LATEST',
-          invokedFunctionArn: actualContext.invokedFunctionArn,
-          invokeid: actualContext.invokeid,
-          logGroupName: actualContext.logGroupName,
-          logStreamName: actualContext.logStreamName,
-          memoryLimitInMB: actualContext.memoryLimitInMB,
-        };
-
-        return expected;
-    };
-
-    const createExpectedConnectHeaders=(actualHeaders)=>{
-      const url=new URL(endpoint); 
-      const expected={
-        Host: url.hostname,
-        'Sec-WebSocket-Extensions': actualHeaders['Sec-WebSocket-Extensions'],
-        'Sec-WebSocket-Key': actualHeaders['Sec-WebSocket-Key'],
-        'Sec-WebSocket-Version': actualHeaders['Sec-WebSocket-Version'],
-        'X-Amzn-Trace-Id': actualHeaders['X-Amzn-Trace-Id'],
-        'X-Forwarded-For': actualHeaders['X-Forwarded-For'],
-        'X-Forwarded-Port': `${url.port||443}`,
-        'X-Forwarded-Proto': `${url.protocol.replace('ws', 'http').replace('wss',  'https').replace(':', '')}`
-      };
-
-      return expected;
-    };
-
-    const createExpectedDisconnectHeaders=(actualHeaders)=>{
-      const url=new URL(endpoint); 
-      const expected={
-        Host: url.hostname,
-        'x-api-key': '',
-        'x-restapi': '',
-      };
-
-      return expected;
-    };
-
-    const createExpectedConnectMultiValueHeaders=(actualHeaders)=>{
-      const expected=createExpectedConnectHeaders(actualHeaders);
-      Object.keys(expected).map((key, index)=>{
-        expected[key] = [expected[key]];
-      });
-      return expected;
-    };
-
-    const createExpectedDisconnectMultiValueHeaders=(actualHeaders)=>{
-      const expected=createExpectedDisconnectHeaders(actualHeaders);
-      Object.keys(expected).map((key, index)=>{
-        expected[key] = [expected[key]];
-      });
-      return expected;
-    };
-
-    it('should receive correct call info', async ()=>{
-      const ws=await createWebSocket();
-      await ws.send(JSON.stringify({action:'registerListener'}));
-      await ws.receive1();
-
-      // connect
-      const c=await createClient();
-      const connect=JSON.parse(await ws.receive1());
-      let now=Date.now(); 
-      let expectedCallInfo={id:c.id, event:{headers:createExpectedConnectHeaders(connect.info.event.headers), multiValueHeaders:createExpectedConnectMultiValueHeaders(connect.info.event.headers), ...createExpectedEvent(c.id, '$connect',  'CONNECT', connect.info.event)}, context:createExpectedContext(connect.info.context)};
-      expect(connect).to.deep.equal({action:'update', event:'connect', info:expectedCallInfo});
-      expect(connect.info.event.requestContext.requestTimeEpoch).to.be.within(connect.info.event.requestContext.connectedAt-10, connect.info.event.requestContext.requestTimeEpoch+10);
-      expect(connect.info.event.requestContext.connectedAt).to.be.within(now-timeout, now);
-      expect(connect.info.event.requestContext.requestTimeEpoch).to.be.within(now-timeout, now);
-      expect(moment.utc(connect.info.event.requestContext.requestTime, 'D/MMM/YYYY:H:m:s Z').toDate().getTime()).to.be.within(now-timeout, now);
-      if (endpoint.startsWith('ws://locahost')) {
-        expect(connect.info.event.apiGatewayUrl).to.equal(endpoint.replace('ws://', 'http://').replace('wss://', 'https://'));
-        expect(connect.info.event.headers['X-Forwarded-For']).to.be.equal('127.0.0.1');
-      }
-
-      // getCallInfo
-      c.ws.send(JSON.stringify({action:'getCallInfo'}));
-      const callInfo=JSON.parse(await c.ws.receive1());
-      now=Date.now(); 
-      expectedCallInfo={event:{body: '{\"action\":\"getCallInfo\"}', ...createExpectedEvent(c.id, 'getCallInfo',  'MESSAGE', callInfo.info.event)}, context:createExpectedContext(callInfo.info.context)};
-      expect(callInfo).to.deep.equal({action:'update', event:'call-info', info:expectedCallInfo});
-      expect(callInfo.info.event.requestContext.connectedAt).to.be.lt(callInfo.info.event.requestContext.requestTimeEpoch);
-      expect(callInfo.info.event.requestContext.connectedAt).to.be.within(now-timeout, now);
-      expect(callInfo.info.event.requestContext.requestTimeEpoch).to.be.within(now-timeout, now);
-      expect(moment.utc(callInfo.info.event.requestContext.requestTime, 'D/MMM/YYYY:H:m:s Z').toDate().getTime()).to.be.within(now-timeout, now);
-      if (endpoint.startsWith('ws://locahost')) expect(callInfo.info.event.apiGatewayUrl).to.equal(endpoint.replace('ws://', 'http://').replace('wss://', 'https://'));
-
-      // disconnect
-      c.ws.close();
-      const disconnect=JSON.parse(await ws.receive1());
-      now=Date.now(); 
-      expectedCallInfo={id:c.id, event:{headers:createExpectedDisconnectHeaders(disconnect.info.event.headers), multiValueHeaders:createExpectedDisconnectMultiValueHeaders(disconnect.info.event.headers), ...createExpectedEvent(c.id, '$disconnect',  'DISCONNECT', disconnect.info.event)}, context:createExpectedContext(disconnect.info.context)};
-      expect(disconnect).to.deep.equal({action:'update', event:'disconnect', info:expectedCallInfo});
-    }).timeout(timeout);
-
-    it('should be able to parse query string', async ()=>{
-      const now=''+Date.now();
-      const ws=await createWebSocket();
-      await ws.send(JSON.stringify({action:'registerListener'}));
-      await ws.receive1();
-
-      const c1=await createClient();
-      const c2=await createClient(`now=${now}&before=123456789`);
-      expect(JSON.parse(await ws.receive1()).info.event.queryStringParameters).to.be.undefined;
-      expect(JSON.parse(await ws.receive1()).info.event.queryStringParameters).to.deep.equal({now, before:'123456789'});
-    }).timeout(timeout);
-
-    it('should be able to receive messages via REST API', async ()=>{
-      const c1=await createClient();
-      const c2=await createClient();
-      const url=new URL(endpoint);
-      const signature = {service: 'execute-api', host:url.host, path:`${url.pathname}/@connections/${c2.id}`, method: 'POST', body:'Hello World!', headers:{'Content-Type':'text/plain'/*'application/text'*/}};
-      aws4.sign(signature, {accessKeyId: cred.accessKeyId, secretAccessKey: cred.secretAccessKey});
-      const res=await req.post(signature.path.replace(url.pathname, '')).set('X-Amz-Date', signature.headers['X-Amz-Date']).set('Authorization', signature.headers['Authorization']).set('Content-Type', signature.headers['Content-Type']).send('Hello World!');
-      expect(res).to.have.status(200);
-      expect(await c2.ws.receive1()).to.equal('Hello World!');
-    }).timeout(timeout);
-
-    it('should receive error code when sending to non existing client via REST API', async ()=>{
-      const c='aJz0Md6VoAMCIbQ=';
-      const url=new URL(endpoint);
-      const signature = {service: 'execute-api', host:url.host, path:`${url.pathname}/@connections/${c}`, method: 'POST', body:'Hello World!', headers:{'Content-Type':'text/plain'/*'application/text'*/}};
-      aws4.sign(signature, {accessKeyId: cred.accessKeyId, secretAccessKey: cred.secretAccessKey});
-      const res=await req.post(signature.path.replace(url.pathname, '')).set('X-Amz-Date', signature.headers['X-Amz-Date']).set('Authorization', signature.headers['Authorization']).set('Content-Type', signature.headers['Content-Type']).send('Hello World!');
-      expect(res).to.have.status(410);
-    }).timeout(timeout);
-
-    // UNABLE TO TEST HIS SCENARIO BECAUSE AWS DOESN'T RETURN ANYTHING
-    // it('should not receive anything when POSTing nothing', async ()=>{
-    //   const c1=await createClient();
-    //   const url=new URL(endpoint);
-    //   const signature = {service: 'execute-api', host:url.host, path:`${url.pathname}/@connections/${c1.id}`, method: 'POST'/*, body:'Hello World!'*/, headers:{'Content-Type':'text/plain'/*'application/text'*/}};
-    //   aws4.sign(signature, {accessKeyId: cred.accessKeyId, secretAccessKey: cred.secretAccessKey});
-    //   const res=await req.post(signature.path.replace(url.pathname, '')).set('X-Amz-Date', signature.headers['X-Amz-Date']).set('Authorization', signature.headers['Authorization']).set('Content-Type', signature.headers['Content-Type']).send(/*'Hello World!'*/);
-    //   expect(res).to.have.status(200);
-    // }).timeout(timeout);
-    
-  });
-});
\ No newline at end of file
diff --git a/manual_test_websocket/manual_test_websocket_main/test/support/WebSocketTester.js b/manual_test_websocket/manual_test_websocket_main/test/support/WebSocketTester.js
deleted file mode 100644
index ee5c8d6..0000000
--- a/manual_test_websocket/manual_test_websocket_main/test/support/WebSocketTester.js
+++ /dev/null
@@ -1,60 +0,0 @@
-const WebSocket = require('ws');
-
-class WebSocketTester {
-  constructor() {
-    this.messages=[]; this.receivers=[];
-  }
-
-  open(url) {
-    if (null!=this.ws) return;
-    const ws=this.ws=new WebSocket(url);
-    ws.on('message', (message)=>{
-      // console.log('Received: '+message);
-      if (0<this.receivers.length) this.receivers.shift()(message);
-      else this.messages.push(message);
-    });
-    return new Promise((resolve/*, reject*/)=> {
-      ws.on('open', ()=>{
-        resolve(true);
-      });
-    });
-  }
-
-  send(data) {
-    this.ws.send(data);
-  }
-
-  receive1() {
-    return new Promise((resolve/*, reject*/)=>{
-      if (0<this.messages.length) resolve(this.messages.shift());
-      else this.receivers.push(resolve);
-    });
-  }
-
-  receive(n) {
-    return new Promise((resolve/*, reject*/)=>{
-      const messages=[];
-      for (let i=0; i<n; i+=1) {
-        this.receive1().then((message)=>{
-          messages[i]=message;
-          if (i===n-1) resolve(messages);
-        });
-      }
-    });
-  }
-
-  skip() {
-    if (0<this.messages.length) this.messages.shift();
-    else this.receivers.push(()=>{});
-  }
-
-  countUnrecived() {
-    return this.messages.length;
-  }
-
-  close() {
-    if (null!=this.ws) this.ws.close();
-  }
-};
-
-module.exports=WebSocketTester;
\ No newline at end of file
-- 
2.21.1 (Apple Git-122.3)

